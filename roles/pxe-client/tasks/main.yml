- name: Include ssh
  vars:
    ssh_delay: 0
    ssh_timeout: 10
    ssh_ping: false
    setup_ssh_after_sshpass: false
  include_role:
    name: ssh

- name: Creates directory
  file:
    path: "{{item}}"
    state: directory
  with_items:
    - "./bootmnt"
    - "./rootmnt"
  when: ansible_distribution is defined and ansible_distribution == "Debian" or ansible_distribution == "Ubuntu"

- debug:
    var: ansible_distribution, scan_known_host.stdout, ssh_con

- name: Check if os_disk1 exists
  stat: 
    path: "{{os_disk}}1"
  register: os_disk1
  when: ssh_con.failed == false and ansible_distribution is defined and ansible_distribution == 'Debian'
- debug:
    var: os_disk1

- name: UMount up boot
  ignore_errors: true
  become: yes
  shell: umount "{{os_disk}}1"
  register: umount
  when: os_disk1.skipped is not defined and os_disk1.stat.exists and ansible_distribution is defined and ansible_distribution == 'Debian'
  failed_when: umount.stderr_lines is defined and umount.stderr_lines[0].find("not mounted.")

- name: Mount up boot
  become: yes
  shell: mount "{{os_disk}}1" "./bootmnt"
  when: os_disk1.skipped is not defined and os_disk1.stat.exists and ansible_distribution is defined and ansible_distribution == 'Debian'
  
- name: Check if ubuntu is enabled
  become: yes
  stat: 
    path: ./bootmnt/start.elf
  register: bootpath
  when: ansible_distribution is defined and ansible_distribution == 'Debian'

- debug:
    var: bootpath

- name: Enable usb boot to switch to ubuntu
  become: yes
  shell: mv "./bootmnt/{{item}}.disable" "./bootmnt/{{item}}"
  when: > 
    bootpath.stat.exists is defined and bootpath.stat.exists == false 
    and os_disk1.skipped is not defined and os_disk1.stat.exists
  with_items:
    - "start4.elf"
    - "start.elf"

- name: Restart server
  ignore_errors: true
  ignore_unreachable: true
  connection: ssh
  shell: sleep 2 && /sbin/shutdown -r now "Ansible system"
  async: 1
  poll: 0
  become: yes
  register: restart
  vars:
    ansible_user: pi
    ansible_password: "{{pi_password}}"
  when: > 
    ansible_distribution is defined and ansible_distribution == 'Debian'
    and os_disk1.skipped is not defined and os_disk1.stat.exists

- name: Include ssh
  vars:
    ssh_delay: 60
    ssh_timeout: 120
    ssh_ping: true
    setup_ssh_after_sshpass: true
    ansible_user: ubuntu
    ssh_user: ubuntu
    ansible_password: "{{ubuntu_password}}"
    ssh_pass: "{{ubuntu_password}}"
  include_role:
    name: ssh
  when: > 
    ansible_distribution is defined and ansible_distribution == 'Debian'
    and os_disk1.skipped is not defined and os_disk1.stat.exists

- name: Unplug {{inventory_hostname}} devices or continue to shutdown
  connection: local
  delegate_to: localhost
  become: false
  register: unplug
  pause:
    seconds: 300
  when: ansible_distribution is not defined
    
- name: Shutdown rapsberry
  become: yes
  ignore_unreachable: true
  command: /sbin/shutdown -h now
  when: >
    unplug.echo is defined and unplug.echo
    and reboot_rapsberry is not defined

- name: Creates directory
  run_once: true
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  file:
    path: "{{item}}"
    state: directory
  with_items:
    - "./{{raspios_img_dir}}"

- name: Check if raspbian os img exists
  run_once: true
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  find: 
    paths: ./{{raspios_img_dir}}
    patterns: raspbianos.img
  register: osimg

- name: Unarchive a file that needs to be downloaded
  run_once: true
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  unarchive:
    src:  https://downloads.raspberrypi.org/raspios_lite_armhf_latest
    dest: ./{{raspios_img_dir}}
    remote_src: yes
  when: osimg.matched == 0

- name: Rename file
  run_once: true
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  shell: "mv ./{{raspios_img_dir}}/*.img ./{{raspios_img_dir}}/raspbianos.img"
  when: osimg.matched == 0

- name: Mount img
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  become: yes
  shell: "x=$(kpartx -a -v ./{{raspios_img_dir}}/raspbianos.img | awk '{print $3}'); echo $x  | cut -d' ' -f1 |rev| cut -c3- | rev"
  register: partx_result

- debug:
   var: partx_result

- name: UMount up boot
  run_once: true
  delegate_to: pxe-server
  connection: ssh
  ignore_errors: true
  vars:
    ansible_user: ubuntu
  become: yes
  shell: umount "/dev/mapper/{{partx_result.stdout}}p1"
  failed_when: umount.stderr_lines is defined and umount.stderr_lines[0].find("not mounted.")

- name: Mount up boot
  run_once: true
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  become: yes
  shell: mount "/dev/mapper/{{partx_result.stdout}}p1" "./bootmnt"
   
- name: UMount up root
  run_once: true
  delegate_to: pxe-server
  connection: ssh
  ignore_errors: true
  vars:
    ansible_user: ubuntu
  become: yes
  shell: umount "/dev/mapper/{{partx_result.stdout}}p2"
  failed_when: umount.stderr_lines is defined and umount.stderr_lines[0].find("not mounted.")

- name: Mount up root
  run_once: true
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  become: yes
  shell: mount "/dev/mapper/{{partx_result.stdout}}p2" "./rootmnt"

- name: Clean boot path
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  become: yes
  file:
    state: absent
    path: "{{boot_path}}"
  when: clean_boot or clean

- name: Clean root path
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  become: yes
  file:
    state: absent
    path: "{{root_path}}"
  when: clean_root or clean

- name: Copy root into place.
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  become: yes
  shell: rsync -azr "./rootmnt/." "{{root_path}}"

- name: Copy boot into place.
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  become: yes
  shell: rsync -azr "./bootmnt/." "{{boot_path}}"

- name: Check pxe is enabled
  delegate_to: pxe-server
  vars:
    ansible_user: ubuntu
  stat:
    path: "{{boot_path}}/start.elf"
  register: pxe_enabled
  when: > 
    os_disk1.skipped is not defined and os_disk1.stat.exists == false
    and ansible_distribution is defined

- name: Disable pxe 
  delegate_to: pxe-server
  vars:
    ansible_user: ubuntu
  become: yes
  shell: mv "{{item}}" "{{item}}.disable"
  with_items:
    -  "{{boot_path}}/start.elf"
    -  "{{boot_path}}/start4.elf"
  register: disable_pxe
  when: > 
    pxe_enabled.skipped is not defined
    and pxe_enabled.stat.exists

- name: Reboot {{inventory_hostname}} raspberry
  shell: sleep 2 && /sbin/shutdown -r now "Ansible system"
  async: 1
  poll: 0
  become: yes
  vars:
    ansible_user: ubuntu
  when: > 
    disable_pxe.skipped is not defined
    and disable_pxe.changed
  register: reboot_rapsberry

- name: Disable Bluetooth and WiFi
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  become: yes
  lineinfile:
    path: "{{boot_path}}/config.txt"
    line: "{{item}}"
    regex: "{{item}}"
    state: present
  register: _config
  with_items:
  - dtoverlay=disable-wifi
  - dtoverlay=disable-bt

- name: Cleanup boot configuration
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  become: yes
  lineinfile:
    path: "{{boot_path}}/cmdline.txt"
    regexp: "UUID=\\d"
    state: absent

- name: Boot configuration
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  become: yes
  lineinfile:
    path: "{{boot_path}}/cmdline.txt"
    line: "{{item}}"
    regex: "{{item}}"
    state: present
  register: _cmdline
  with_items:
  - "console=serial0,115200 console=tty1 root=/dev/nfs nfsroot={{pxe_host}}:{{root_path}},vers=4.1,proto=tcp rw ip=dhcp rootwait elevator=deadline"

- name: Cleanup fstab
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  become: yes
  lineinfile:
    path: "{{root_path}}/etc/fstab"
    regexp: "UUID=\\d"
    state: absent

- name: fstab configuration
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  become: yes
  lineinfile:
    path: "{{root_path}}/etc/fstab"
    line: "{{item}}"
    regex: "{{item}}"
    state: present
  register: _fstab
  with_items:
  - "{{pxe_host}}:{{boot_path}} /boot nfs defaults,vers=4.1,proto=tcp 0 0"

- name: Exports configuration
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  become: yes
  lineinfile:
    path: "/etc/exports"
    line: "{{item}}"
    regex: "{{item}}"
    state: present
  register: _exports
  with_items:
  - "{{root_path}} *(rw,sync,no_subtree_check,no_root_squash)"
  - "{{boot_path}} *(rw,sync,no_subtree_check,no_root_squash)"

- name: Restart services
  run_once: true
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  become: yes
  systemd:
    name: "{{item}}"
    state: "restarted"
  with_items:
    - nfs-server
    - tftpd-hpa
  
- name: Reload systemd
  run_once: true
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  become: yes
  command: systemctl daemon-reload

- name: Check if ssh exists
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  stat: path="{{boot_path}}/ssh"
  register: ssh

- name: Enable ssh
  delegate_to: pxe-server
  connection: ssh
  vars:
    ansible_user: ubuntu
  become: yes
  file: 
    path: "{{boot_path}}/ssh"
    state: touch
  when: ssh.stat.exists == false

- name: Plug {{inventory_hostname}} device and continue
  connection: local
  delegate_to: localhost
  become: false
  pause:
    seconds: 300
  when:  ansible_distribution is not defined

- debug:
    var: ansible_distribution
  when: ansible_distribution is defined

- name: Check pxe is enabled
  delegate_to: pxe-server
  vars:
    ansible_user: ubuntu
  stat:
    path: "{{boot_path}}/start.elf"
  register: pxe_enabled
  when: > 
    os_disk1.skipped is not defined and os_disk1.stat.exists == false
    and ansible_distribution is defined
    
- name: Enable pxe 
  become: yes
  delegate_to: pxe-server
  vars:
    ansible_user: ubuntu
  shell: mv "{{item}}.disable" "{{item}}"
  with_items:
    -  "{{boot_path}}/start.elf"
    -  "{{boot_path}}/start4.elf"
  register: disable_pxe
  when: > 
    pxe_enabled.skipped is not defined
    and pxe_enabled.stat.exists == false

- name: Check if ubuntu is enabled
  become: yes
  stat: path={%if ansible_distribution == 'Ubuntu'%}/boot/firmware/start.elf{%else%}./bootmnt/start.elf{%endif%}
  register: bootpath
  when: >
    ansible_distribution is defined
    and os_disk1.skipped is not defined and os_disk1.stat.exists

- debug:
    var: bootpath
  when: ansible_distribution is defined
  
- name: Disable usb boot to switch to raspberry
  become: yes
  shell: mv "{{item}}" "{{item}}.disable"
  when: > 
    ansible_distribution is defined 
    and bootpath.skipped is not defined
    and bootpath.stat.exists
    and os_disk1.skipped is not defined 
    and os_disk1.stat.exists
  with_items:
    - "{%if ansible_distribution == 'Ubuntu'%}/boot/firmware/start.elf{%else%}./bootmnt/start.elf{%endif%}"
    - "{%if ansible_distribution == 'Ubuntu'%}/boot/firmware/start4.elf{%else%}./bootmnt/start4.elf{%endif%}"
  register: switch_to_raspberry

- name: Restart server
  shell: sleep 2 && /sbin/shutdown -r now "Ansible system"
  async: 1
  poll: 0
  become: yes
  register: restart
  vars:
    ansible_user: ubuntu
  when: >
    ansible_distribution is defined 
    and switch_to_raspberry.changed is defined and switch_to_raspberry.changed
    and os_disk1.skipped is not defined and os_disk1.stat.exists

- name: Include ssh
  include_role:
    name: ssh
  vars:
    ssh_delay: 20
    ssh_timeout: 300
    ssh_ping: true
    setup_ssh_after_sshpass: true
    ssh_user: pi
    ansible_user: pi
    ssh_pass: "{{pi_password}}"
    ansible_password: "{{pi_password}}"
  when: clean or restart.changed or setup.unreachable is defined and setup.unreachable 